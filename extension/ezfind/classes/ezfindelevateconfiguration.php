<?php
//
//
// ## BEGIN COPYRIGHT, LICENSE AND WARRANTY NOTICE ##
// SOFTWARE NAME: eZ Find
// SOFTWARE RELEASE: 2.0.x
// COPYRIGHT NOTICE: Copyright (C) 2009 eZ Systems AS
// SOFTWARE LICENSE: GNU General Public License v2.0
// NOTICE: >
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of version 2.0  of the GNU General
//   Public License as published by the Free Software Foundation.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of version 2.0 of the GNU General
//   Public License along with this program; if not, write to the Free
//   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//   MA 02110-1301, USA.
//
//
// ## END COPYRIGHT, LICENSE AND WARRANTY NOTICE ##
//

/**
 * File containing the eZFindElevateConfiguration class.
 *
 * @package eZFind
 */
class eZFindElevateConfiguration extends eZPersistentObject
{
    /**
     * XML string used to generate the elevate confguration for Solr.
     *
     * @var string
     */
    const XML_SKELETON = '<?xml version="1.0" encoding="UTF-8" ?><elevate></elevate>';

    /**
     * Character used to symbolize that the queryString will elevate a given
     * content object for ALL languages.
     *
     * @var string
     */
    const WILDCARD = '*';

    /**
     * Name of the file used by Solr to load the Elevate configuration
     *
     * @var string
     */
    const ELEVATE_CONF_FILENAME = 'elevate.xml';

    /**
     * Storing solr.ini
     * Initialized by the end of this file.
     *
     * @var eZINI
     */
    public static $solrINI;

    /**
     * Used as a data transmission artifact.
     * Will store the configuration XML string once it was generated by the method generateConfiguration()
     *
     * @see function generateConfiguration()
     * @var string
     */
    protected static $configurationXML = null;

    /**
     * Constructor. Will create a new configuration row.
     *
     * @param array $row Contains the values for each column in the DB.
     */
    public function __construct( $row )
    {
        $this->eZPersistentObject( $row );
    }

    /**
     * Mandatory method defining the eZFindElevationConfiguration persistent object
     *
     * @return array An array defining the eZFindElevationConfiguration persistent object
     */
    public static function definition()
    {
        return array(
            "fields" => array( "search_query"     => array(    'name' => 'searchQuery',
                                                               'datatype' => 'string',
                                                               'default' => '',
                                                               'required' => true ),
                               "contentobject_id" => array(    'name' => 'contentObjectId',
                                                               'datatype' => 'int',
                                                               'default' => 0,
                                                               'required' => true ),
                               "language_code"    => array(    'name' => 'languageCode',
                                                               'datatype' => 'string',
                                                               'default' => '',
                                                               'required' => true )
                             ),
            "keys" => array( "search_query", "contentobject_id", "language_code" ),
            "function_attributes" => array(),
            "class_name" => "eZFindElevateConfiguration",
            "sort" => array( "contentobject_id" => "asc" ),
            "name" => "ezfind_elevate_configuration"
        );
    }

    /**
     * Retrieves the query strings triggering elevation for a given content object, possibly per language.
     *
     * @param int $objectID ID of the content object to fetch elevate configuration for
     * @param string $languageCode if filtering on language-code is required
     * @return mixed An array containing the query strings elevating the object, optionnally sorted by language code, null if error.
     */
    public static function fetchQueryStringsForObject( $objectID, $groupByLanguage = true, $languageCode = null )
    {
        if ( ! is_numeric( $objectID ) )
            return null;

        $queryStrings = array();
        $sortClause = $groupByLanguage ? array( 'language_code' => 'asc' ) : null;

        $conds = array( 'contentobject_id' => $objectID );
        if ( $languageCode and $languageCode !== '' )
            $conds['language_code'] = array( array( $languageCode, self::WILDCARD ) );

        $rows = parent::fetchObjectList( self::definition(), null, $conds, $sortClause, null, false );

        foreach( $rows as $row )
        {
            if ( $groupByLanguage )
            {
                $queryStrings[$row['language_code']][] = $row['search_query'];
            }
            else
            {
                $queryStrings[] = $row['search_query'];
            }
        }

        return $queryStrings;
    }

    /**
     * Retrieves the content objects elevated by a given query string, possibly per language.
     *
     * @param string $queryString query string for which elevate configuration is retrieved
     * @param string $languageCode if filtering on language-code is required
     * @return mixed An array containing the content objects elevated by the query string, optionnally sorted by language code, null if error.
     */
    public static function fetchObjectsForQueryString( $queryString, $groupByLanguage = true, $languageCode = null )
    {
        if ( $queryString === '' )
            return null;

        $objects = array();
        $sortClause = $groupByLanguage ? array( 'language_code' => 'asc' ) : null;

        $conds = array( 'search_query' => $queryString );
        if ( $languageCode and $languageCode !== '' )
            $conds['language_code'] = array( array( $languageCode, self::WILDCARD ) );

        $rows = parent::fetchObjectList( self::definition(), null, $conds, $sortClause, null, false );

        foreach( $rows as $row )
        {
            if ( ( $obj = eZContentObject::fetch( $row['contentobject_id'] ) ) !== null )
            {
                if ( $groupByLanguage )
                {
                    $objects[$row['language_code']][] = $obj;
                }
                else
                {
                    $objects[] = $obj;
                }
            }
        }

        return $objects;
    }


    /**
     * Adds an elevate configuration row, optionnally for a given language.
     *
     * @param string $queryString Query string for which elevate configuration is added
     * @param int $objectID Content object for which the elevate configuration is added
     * @param string $languageCode Language code for which the elevate configuration is added. Defaults to 'all languages'
     */
    public static function add( $queryString, $objectID, $languageCode = self::WILDCARD )
    {
        $db = eZDB::instance();
        $queryString = $db->escapeString( $queryString );

        if ( $languageCode === self::WILDCARD )
        {
            self::purge( $queryString, $objectID );
        }
        else
        {
            // tring to insert an elevate configuration row for a specific language, while one already exists for all languages.
            if ( parent::fetchObject( self::definition(), null, array( 'contentobject_id' => $objectID, 'search_query' => $queryString, 'language_code' => self::WILDCARD ) ) )
                return null;
        }

        $row = array( 'search_query'     => $queryString,
                      'contentobject_id' => $objectID,
                      'language_code'    => $languageCode );

        $conf = new eZFindElevateConfiguration( $row );
        $conf->store();
        return $conf;
    }

    /**
     * Purges the configuration rows for a given query string, a given object, or both.
     *
     * @param string $queryString Query string for which elevate configuration is removed
     * @param int $objectID Content object for which the elevate configuration is removed
     * @param string $languageCode Language code for which the elevate configuration is removed. Defaults to 'all languages'
     */
    public static function purge( $queryString = '' , $objectID = null, $languageCode = null )
    {
        // check that some conditions were passed
        if ( $queryString === '' and $objectID === null and $languageCode === null )
            return false;

        if ( $queryString !== '' )
            $conds['search_query'] = $queryString;

        if ( $objectID !== null )
            $conds['contentobject_id'] = $objectID;

        if ( $languageCode !== null )
            $conds['language_code'] = $languageCode;

        return parent::removeObject( self::definition(), $conds );
    }

    /**
     * Synchronises the elevate configuration stored in the DB
     * with the one actually used by Solr.
     *
     * @return boolean true is the whole operation passed, false otherwise.
     */
    public static function synchroniseWithSolr()
    {
        if ( self::generateConfiguration() )
        {
            try
            {
                self::pushConfigurationToSolr();
            }
            catch ( Exception $e )
            {
                return false;
            }
        }
        else
        {
            eZDebug::writeError( "Error while generating the configuration XML", 'eZFindElevateConfiguration::synchroniseWithSolr' );
            return false;
        }

        return true;
    }

    /**
     * Extracts the configuration stored in the DB and turns it into a Solr-compliant XML string.
     * Stores the result string in the local property $configurationXML
     *
     * @see $configurationXML
     * @return boolean true if the generation run correclty, false otherwise.
     */
    protected static function generateConfiguration()
    {
        $db = eZDB::instance();
        $def = self::definition();
        $query = "SELECT DISTINCT search_query FROM ". $def['name'];
        $limit = 50;
        $offset = 0;
        $querySuffix = " LIMIT $limit OFFSET $offset";

        $xml = new SimpleXMLElement( self::XML_SKELETON );
        self::$configurationXML = $xml->asXML();

        while( true )
        {
            // fetch distinct search queries
            $rows = $db->arrayQuery( $query . $querySuffix );
            if ( empty( $rows ) )
                break;

            // For each query string, generate the corresponding bloc in elevate.xml
            // Looks like this :
            //
            // <query text="foo bar">
            //    <doc id="1" />
            //    <doc id="2" />
            //    <doc id="3" />
            // </query>
            $xml = new SimpleXMLElement( self::$configurationXML );
            foreach( $rows as $row )
            {
                $searchQuery = $xml->addChild( 'query' );
                $searchQuery->addAttribute( 'text', $row['search_query'] );

                $results = self::fetchObjectsForQueryString( $row['search_query'] );
                foreach( $results as $languageCode => $objects )
                {
                    foreach( $objects as $object )
                    {
                        if ( $languageCode === self::WILDCARD )
                        {
                            $currentVersion = $object->currentVersion();
                            foreach ( $currentVersion->translationList( false, false ) as $lang )
                            {
                                $guid = eZSolr::guid( $object, $lang );
                                $doc = $searchQuery->addChild( 'doc' );
                                $doc->addAttribute( 'id', $guid );
                            }
                        }
                        else
                        {
                            $guid = eZSolr::guid( $object, $languageCode );
                            $doc = $searchQuery->addChild( 'doc' );
                            $doc->addAttribute( 'id', $guid );
                        }
                    }
                }
            }

            $offset += $limit;
            $querySuffix = " LIMIT $limit OFFSET $offset";
            self::$configurationXML = $xml->asXML();
        }
        return true;
    }

    /**
     * Simple static getter to the configuration XML
     *
     * @see $configurationXML
     * @return mixed A string containing the configuration XML, null otherwise ( default value of $configurationXML )
     */
    protected static function getConfiguration()
    {
        return self::$configurationXML;
    }

    /**
     * Pushes the configuration XML to Solr. Different push methods might be used
     *   * phase 1 : direct update of the XML file, locally.
     *   * phase 2 : push to Solr through a requestHandler
     *
     * @see $configurationXML
     * @return void
     */
    protected static function pushConfigurationToSolr()
    {
        $filePath = rtrim( self::$solrINI->variable( 'SolrBase', 'DataDirFullPath' ), '/' ) . '/' . self::ELEVATE_CONF_FILENAME;
        if ( ( $fh = fopen( $filePath, 'w' ) ) === false )
        {
            $message = 'Unable to open \'' . $filePath . '\'. Write access is required on this file in order to flush Solr\'s elevate configuration.';
            eZDebug::writeError( $message, 'eZFindElevateConfiguration::pushConfigurationToSolr' );
            throw new Exception( $message );
        }

        if ( fwrite( $fh, self::getConfiguration() ) === false )
        {
            $message = 'Unable to write Solr\'s elevate configuration in \'' . $filePath . '\', although the file could be properly opened.';
            eZDebug::writeError( $message, 'eZFindElevateConfiguration::pushConfigurationToSolr' );
            throw new Exception( $message );
        }

        // Triggering a commit makes sure the elevate configuration is reloaded.
        $solr = new eZSolr();
        $solr->commit();
    }

    /**
     * Generates a well-formed array of elevate-related query parameters.
     *
     * @param boolean $forceElevation Whether elevation should be forced or not. Parameter supported at runtime from Solr@rev:735117
     *                Should be used when a sort array other than the default one ( 'score desc' ) is passed in the query parameters,
     *                if one wants the elevate configuration to be actually taken into account.
     *
     * @param boolean $enableElevation Whether the Elevate functionnality should be used or not. Defaults to 'true'.
     *
     * @return array The well-formed query parameter regarding the elevate functionnality. Example :
     *         <code>
     *         array( 'forceElevation' => 'true',
     *                'enableElevation' => 'true' )
     *         </code>
     */
    public static function getRuntimeQueryParameters( $forceElevation = false, $enableElevation = true )
    {
        $retArray = array( 'forceElevation'  => 'false',
                           'enableElevation' => 'true' );

        if ( $enableElevation === false )
        {
            $retArray['enableElevation'] = 'false';
            return $retArray;
        }

        if ( $forceElevation === true )
        {
            $retArray['forceElevation'] = 'true';
        }

        return $retArray;
    }
}
// Initialize the static property containing <eZINI> solr.ini
eZFindElevateConfiguration::$solrINI = eZINI::instance( 'solr.ini' );
?>